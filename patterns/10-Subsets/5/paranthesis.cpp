// System headers
#include <string>
#include <vector>
#include <queue>
#include <stdexcept>

// Local includes
#include "paranthesis.h"

// Using declarations
using std::vector;
using std::queue;
using std::string;
using std::domain_error;

// Statics, typedefs, globals

vector<string>
Permutations::generateBalancedParanthesisPairs(unsigned int nPairs) {
    if (0 == nPairs) {
        throw domain_error("Error! Invalid number of input pairs!");
    }

    // Vector holding all permutations of balanced paranthesis for
    // given number of pairs
    vector<string> finalPermutationsV;
    // BFS Queue holding intermediate permutations of balanced
    // paranthesis used while generating the final permutations
    queue<ParanthesisStr> intermediatePermutationsQ;
    // Commence by enqueueing null paranthesis string onto the BFS Q
    intermediatePermutationsQ.push({"", 0, 0});
    // Keep dequeueing elements from the BFS queue till it is not empty
    // building up the intermediate sets of balanced paranthesis strings
    // till the ones with required number of paranthesis pairs get generated
    while (!intermediatePermutationsQ.empty()) {
        // Dequeue the paranthesis string from the front of BFS intermediate
        // permutations Q
        ParanthesisStr ps = intermediatePermutationsQ.front();
        intermediatePermutationsQ.pop();

        // If dequeued paranthesis string is balanced and has the required
        // numbers of paranthesis pairs, add it to final permutations list
        if (ps.balanced() && ps.openCnt() == nPairs) {
            finalPermutationsV.push_back(ps.paraStr());
        } else {
            // Dequeued paranthesis string does not have requisiste number
            // of paranthesis pairs or is unbalanced

            // Attempt to form new intermediate permutation by adding a "("
            // open paranthesis to dequeued paranthesis string and enqueue
            // it to BFS Q for further processing
            if (ps.openCnt() < nPairs) {
                intermediatePermutationsQ.push(
                    {ps.paraStr() + "(", ps.openCnt() + 1, ps.closedCnt()});
            }
            // Attempt to form new intermediate permutation by adding a ")"
            // closed paranthesis to dequeued paranthesis string and enqueue
            // it to BFS Q for further processing
            if (ps.openCnt() > ps.closedCnt()) {
                intermediatePermutationsQ.push(
                    {ps.paraStr() + ")", ps.openCnt(), ps.closedCnt() + 1});
            }
        }
    }

    return finalPermutationsV;
}

void
Permutations::generateBalancedParanthesisPairsViaRecursion(
    unsigned int nPairs, const ParanthesisStr& intermediateParaStr,
    vector<string>& finalPermutationsV) {

    // Intermediate paranthesis string generated in last recursion
    // call is balanced and has requisite numbers of open and closed
    // paranthesis, add it to the final list of balanced paranthesis
    // permutations
    if (intermediateParaStr.balanced() &&
        intermediateParaStr.openCnt() == nPairs) {
        finalPermutationsV.push_back(intermediateParaStr.paraStr());
        return;
    }

    // Attempt to add an open paranthesis "(" to the intermediate
    // paranthesis string generated in last recursion call
    if (intermediateParaStr.openCnt() < nPairs) {
        ParanthesisStr newParaStr(
            intermediateParaStr.paraStr() + "(",
            intermediateParaStr.openCnt() + 1,
            intermediateParaStr.closedCnt());
        // Use intermediate paranthesis string generated by adding open
        // paranthesis "(" to recursively find the list of all balanced
        // paranthesis permutations for a given number of paranthesis pairs
        generateBalancedParanthesisPairsViaRecursion(
            nPairs, newParaStr, finalPermutationsV);
    }

    // Attempt to add a closed paranthesis ")" to the intermediate
    // paranthesis string generated in last recursion call
    if (intermediateParaStr.openCnt() > intermediateParaStr.closedCnt()) {
        ParanthesisStr newParaStr(
            intermediateParaStr.paraStr() + ")",
            intermediateParaStr.openCnt(),
            intermediateParaStr.closedCnt() + 1);
        // Use intermediate paranthesis string generated by adding closed
        // paranthesis ")" to recursively find the list of all balanced
        // paranthesis permutations for a given number of paranthesis pairs
        generateBalancedParanthesisPairsViaRecursion(
            nPairs, newParaStr, finalPermutationsV);
    }
}

vector<string>
Permutations::generateBalancedParanthesisPairsViaRecursion(
    unsigned int nPairs) {
    if (0 == nPairs) {
        throw domain_error("Error! Invalid number of input pairs!");
    }
    // Vector holding all permutations of balanced paranthesis for
    // given number of pairs
    vector<string> finalPermutationsV;
    // Commence by starting off with a null paranthesis string
    ParanthesisStr pStr("", 0, 0);
    // Recursively find all sets of balanced paranthesis for a given
    // number of paranthesis
    generateBalancedParanthesisPairsViaRecursion(
        nPairs, pStr, finalPermutationsV);
    return finalPermutationsV;
}
