// System headers
#include <vector>
#include <unordered_set>
#include <stdexcept>
#include <algorithm>

// Local includes
#include "findNum.h"

// Using declarations
using std::vector;
using std::unordered_set;
using std::domain_error;
using std::swap;

// Statics, typedefs, globals

vector<int>
FindNum::findFirstKMissingPositive(const vector<int>& iv, int k){
    if (iv.empty()) {
        throw domain_error("Error! Empty input vec!");
    }

    // Do a cyclic sort of input vector elements with
    // a local copy
    vector<int> v(iv.begin(), iv.end());

    typedef vector<int>::size_type vecSzT;
    // Examine all elements of input vector and cyclic sort all +ve
    // numbers to their sorted/appropriate indices. Input array
    // should contain only +ve elements in range [1, v.size()]
    vecSzT i = 0;
    while (i != v.size()) {
        if (v[i] <= 0 || v[i] > v.size()) {
            // Skip out of +ve range numbers
            ++i;
        } else {
            // Determine correct sorted location of element v[i]
            vecSzT correctIdx = v[i] - 1;
            // Check if element v[i] is at its correct sorted location
            if (v[correctIdx] != v[i]) {
                // Element v[i] is not at its correct sorted location, so
                // move it to its correct sorted location via an exchange
                swap(v[i], v[correctIdx]);
            } else {
                // Element v[i] is at its correct sorted location, move
                // to next element
                ++i;
            }
        }
    }

    // Examine all elements of sorted input vector, and find the first
    // missing +ve k elements in cyclically sorted input vector upto
    // [1, v.size()]. If 'k' missing elements are not found, rest have
    // to generated by moving beyond last possible vector element v.size()
    vector<int> missingNumV;
    unordered_set<int> outOfRangeNos;
    for (i = 0; i != v.size() && k; ++i) {
        if (v[i] != i + 1) {
            // Missing element in vector range [1, v.size()]
            missingNumV.push_back(i + 1);
            --k;
            // v[i] is an out of range number and is segregated as such
            outOfRangeNos.insert(v[i]);
        }
    }

    // Now the remainder missing elements would be beyond sorted vector
    // size. However some may still be in the vector (as their values
    // are beyond vector size range [1, v.size()] and have to be skipped)
    // Keep generating extra numbers beyond vector range and fill in
    // the missing numbers
    vecSzT candidateNum = v.size() + 1;
    while (k) {
        if (outOfRangeNos.find(candidateNum) == outOfRangeNos.end()) {
            // Current Out of range [1, v.size()] element i not present
            // in original vector. Add to missing numbers
            missingNumV.push_back(candidateNum);
            --k;
        }
        ++candidateNum;
    }

    return missingNumV;
}
